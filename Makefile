##################################################################
#
# Makefile for Metaphor experiments
#
##################################################################

default: verify

# This just straighforwardly builds a verification version of the 
# current compiler, to check that we actually do have a fixed point
verify-core.py: metaphor-compiler.py metaphor-grammar.txt
	./metaphor-compiler.py metaphor-grammar.txt > verify-core.py
verify-metaphor-compiler.py: combiner metaphor-runtime-header.py verify-core.py  metaphor-runtime-trailer.py 
	./combiner metaphor-runtime-header.py verify-core.py metaphor-runtime-trailer.py > verify-metaphor-compiler.py
	chmod +x verify-metaphor-compiler.py

verify: verify-metaphor-compiler.py
	diff verify-metaphor-compiler.py metaphor-compiler.py 

# To modify the compiler and not go mad, we need to be more systematic
TRANSIENTS = new-in-old-metaphor-grammar.txt \
             new-in-new-metaphor-grammar.txt \
             new-metaphor-runtime-header.py \
             new-metaphor-runtime-trailer.py \
             new-combiner
# First, "prepare" copies relevant files and we only modify *them*
prepare:
	cp metaphor-grammar.txt        new-in-old-metaphor-grammar.txt
	cp metaphor-grammar.txt        new-in-new-metaphor-grammar.txt
	cp metaphor-runtime-header.py  new-metaphor-runtime-header.py
	cp metaphor-runtime-trailer.py new-metaphor-runtime-trailer.py
	cp combiner                    new-combiner
	git add $(TRANSIENTS)

# Next "fixedpoint" tries to make a series of new compilers and checks that
# the 3rd and 4th are identical, proving we've reached a fixed point
# 1st: grammar for new language written in syntax of old; uses old runtime
new-core1.py: metaphor-compiler.py new-in-old-metaphor-grammar.txt
	./metaphor-compiler.py new-in-old-metaphor-grammar.txt > new-core1.py
new-metaphor-compiler1.py: combiner metaphor-runtime-header.py new-core1.py metaphor-runtime-trailer.py 
	./combiner metaphor-runtime-header.py new-core1.py metaphor-runtime-trailer.py > new-metaphor-compiler1.py
	chmod +x new-metaphor-compiler1.py

# 2nd: grammar for new language written in new syntax; uses new runtime
# (But note: new-core2.py is generated by the *old* runtime, so this 
# compiler can't possibly be a fixed point)
new-core2.py: new-metaphor-compiler1.py new-in-new-metaphor-grammar.txt
	./new-metaphor-compiler1.py new-in-new-metaphor-grammar.txt > new-core2.py
new-metaphor-compiler2.py: new-combiner new-metaphor-runtime-header.py new-core2.py new-metaphor-runtime-trailer.py 
	./new-combiner new-metaphor-runtime-header.py new-core2.py new-metaphor-runtime-trailer.py > new-metaphor-compiler2.py
	chmod +x new-metaphor-compiler2.py

# 3rd: grammar for new language written in new syntax; uses new runtime
# (This time, core is generated by the *new* runtime, so this should
# be a fixed point, but we will need to go round again to check that)
new-core3.py: new-metaphor-compiler2.py new-in-new-metaphor-grammar.txt
	./new-metaphor-compiler2.py new-in-new-metaphor-grammar.txt > new-core3.py
new-metaphor-compiler3.py: new-combiner new-metaphor-runtime-header.py new-core3.py new-metaphor-runtime-trailer.py 
	./new-combiner new-metaphor-runtime-header.py new-core3.py new-metaphor-runtime-trailer.py > new-metaphor-compiler3.py
	chmod +x new-metaphor-compiler3.py

# 4th: as before, but this now should be the fixed-point
new-core4.py: new-metaphor-compiler3.py new-in-new-metaphor-grammar.txt
	./new-metaphor-compiler3.py new-in-new-metaphor-grammar.txt > new-core4.py
new-metaphor-compiler4.py: new-combiner new-metaphor-runtime-header.py new-core4.py new-metaphor-runtime-trailer.py 
	./new-combiner new-metaphor-runtime-header.py new-core4.py new-metaphor-runtime-trailer.py > new-metaphor-compiler4.py
	chmod +x new-metaphor-compiler4.py

fixedpoint: new-metaphor-compiler1.py new-metaphor-compiler2.py new-metaphor-compiler3.py new-metaphor-compiler4.py
	diff new-metaphor-compiler3.py new-metaphor-compiler4.py 

# To try out the fixed-point compiler on a little example, we have 
# the "test" target (test-grammar.txt and test-example.txt should be
# hacked around as needed to try out the facilities of the fixed-point 
# compiler before accepting it)

test-core.py: fixedpoint test-grammar.txt
	./new-metaphor-compiler4.py test-grammar.txt > test-core.py
test-compiler.py: new-combiner new-metaphor-runtime-header.py test-core.py new-metaphor-runtime-trailer.py 
	./new-combiner new-metaphor-runtime-header.py test-core.py new-metaphor-runtime-trailer.py > test-compiler.py
	chmod +x test-compiler.py
test: test-compiler.py test-example.txt
	./test-compiler.py test-example.txt # we just want to eyeball the output

# Lastly, "accept" updates the current grammar etc with the new ones,
# privided it's safe to do that update (i.e. if we have the fixed-point)
accept: fixedpoint
	cp metaphor-compiler.py old-metaphor-compiler.py
	rm new-core1.py new-metaphor-compiler1.py
	rm new-core2.py new-metaphor-compiler2.py
	rm new-core3.py new-metaphor-compiler3.py
	rm new-core4.py 
	cp new-metaphor-compiler4.py metaphor-compiler.py
	cp new-in-new-metaphor-grammar.txt metaphor-grammar.txt 
	cp new-metaphor-runtime-header.py metaphor-runtime-header.py
	cp new-metaphor-runtime-trailer.py metaphor-runtime-trailer.py
	cp new-combiner combiner
	rm new-metaphor-compiler4.py
	git rm -f $(TRANSIENTS)

#-------------------------------------------------------------
# Example compiler using the AEXP grammar & runtime

aexp-core.py: metaphor-compiler.py aexp-grammar.txt
	./metaphor-compiler.py aexp-grammar.txt > aexp-core.py
aexp-compiler.py: combiner metaphor-runtime-header.py aexp-core.py metaphor-runtime-trailer.py 
	./combiner metaphor-runtime-header.py aexp-core.py metaphor-runtime-trailer.py > aexp-compiler.py
	chmod +x aexp-compiler.py

aexp-example-object.py: aexp-compiler.py aexp-example.txt aexp-runtime-header.py aexp-runtime-trailer.py
	cat aexp-runtime-header.py > tmp.txt
	./aexp-compiler.py aexp-example.txt >> tmp.txt
	cat aexp-runtime-trailer.py >> tmp.txt
	mv tmp.txt aexp-example-object.py
	chmod +x aexp-example-object.py

test-aexp: aexp-example-object.py
	./aexp-example-object.py

clean:
	rm -f verify-core.py verify-metaphor-compiler.py
	rm -f new-core1.py new-metaphor-compiler1.py
	rm -f new-core2.py new-metaphor-compiler2.py
	rm -f new-core3.py new-metaphor-compiler3.py
	rm -f new-core4.py new-metaphor-compiler4.py
	rm -f aexp-core.py aexp-compiler.py aexp-example-object.py 
	rm -f test-core.py test-compiler.py *~ 

realclean: clean
	git rm -f $(TRANSIENTS)

